#!/usr/bin/env node

/**
 * Manual Test for Maestro Specs-Driven Flow with Agent Reuse
 * Tests the enhanced maestro orchestrator functionality
 */

import { readFile, writeFile, mkdir } from 'fs/promises';
import { join } from 'path';

// Mock implementations for testing
class MockEventBus {
  emit(event, data) {
    console.log(`ğŸ“¡ Event: ${event}`, data);
  }
  on() {}
}

class MockLogger {
  info(msg) { console.log(`â„¹ï¸  ${msg}`); }
  warn(msg) { console.log(`âš ï¸  ${msg}`); }
  error(msg) { console.log(`âŒ ${msg}`); }
  debug(msg) { console.log(`ğŸ› ${msg}`); }
}

class MockMemoryManager {
  async store() {}
  async retrieve() {}
}

class MockAgentManager {
  constructor() {
    this.agents = new Map();
  }
  
  async createAgent(type, profile) {
    const agentId = `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
    this.agents.set(agentId, { type, profile, status: 'created' });
    console.log(`ğŸ¤– Created agent: ${agentId} (${type})`);
    return agentId;
  }
  
  async startAgent(agentId) {
    const agent = this.agents.get(agentId);
    if (agent) {
      agent.status = 'running';
      console.log(`â–¶ï¸  Started agent: ${agentId}`);
    }
  }
  
  async stopAgent(agentId) {
    const agent = this.agents.get(agentId);
    if (agent) {
      agent.status = 'stopped';
      console.log(`â¹ï¸  Stopped agent: ${agentId}`);
      this.agents.delete(agentId);
    }
  }
}

class MockOrchestrator {
  async assignTask(task) {
    console.log(`ğŸ“‹ Task assigned to agent ${task.assignedAgent}: ${task.description}`);
    // Simulate task execution
    await new Promise(resolve => setTimeout(resolve, 100));
    return { success: true, duration: 100 };
  }
}

// Test the maestro orchestrator
async function testMaestroWithAgentReuse() {
  console.log('ğŸ§ª Testing Maestro Specs-Driven Flow with Agent Reuse');
  console.log('=' .repeat(60));

  // Mock config
  const config = { enableHiveMind: false };
  
  // Create mock dependencies
  const eventBus = new MockEventBus();
  const logger = new MockLogger();
  const memoryManager = new MockMemoryManager();
  const agentManager = new MockAgentManager();
  const mainOrchestrator = new MockOrchestrator();

  // Simple implementation of the core MaestroOrchestrator functionality
  class TestMaestroOrchestrator {
    constructor() {
      this.maestroState = new Map();
      this.agentPool = new Map();
      this.capabilityIndex = new Map();
      this.logger = logger;
      this.agentManager = agentManager;
      this.mainOrchestrator = mainOrchestrator;
    }

    async createSpec(featureName, initialRequest) {
      console.log(`\nğŸ“‹ Creating spec for: ${featureName}`);
      
      const workflowState = {
        featureName,
        currentPhase: 'Requirements Clarification',
        currentTaskIndex: 0,
        status: 'active',
        lastActivity: new Date(),
        history: []
      };
      
      this.maestroState.set(featureName, workflowState);
      
      // Create specs directory structure
      const specsDir = join(process.cwd(), 'docs', 'maestro', 'specs', featureName);
      await mkdir(specsDir, { recursive: true });
      
      const requirementsContent = `# Requirements for ${featureName}

## High-Level Request
${initialRequest}

## User Stories
- As a developer, I want ${initialRequest.toLowerCase()}, so that I can verify functionality

## Acceptance Criteria
- [ ] Feature functions as described
- [ ] Agent reuse is working properly
- [ ] Performance is optimized

*Generated by Test Maestro Orchestrator*
`;
      
      await writeFile(join(specsDir, 'requirements.md'), requirementsContent);
      console.log(`âœ… Spec created at: docs/maestro/specs/${featureName}/requirements.md`);
    }

    async generateDesign(featureName) {
      console.log(`\nğŸ¨ Generating design for: ${featureName}`);
      
      // Test the enhanced agent selection
      const designTask = {
        id: `design-${featureName}`,
        type: 'design-generation',
        description: `Generate design for ${featureName}`,
        metadata: { featureName }
      };

      // Simulate the new agent selection logic
      const optimalAgentTypes = await this.getOptimalAgentTypes(
        ['design', 'architecture', 'analysis'],
        'design-generation',
        2
      );

      console.log(`ğŸ”„ Selected agent types: ${optimalAgentTypes.join(', ')}`);
      
      await this.executeTaskWithManagedAgent(
        optimalAgentTypes,
        designTask,
        ['design', 'architecture', 'analysis']
      );

      // Create design file
      const specsDir = join(process.cwd(), 'docs', 'maestro', 'specs', featureName);
      await mkdir(specsDir, { recursive: true });
      const designContent = `# Design for ${featureName}

## Architecture Overview
System designed using enhanced agent reuse functionality.

## Agent Reuse Statistics
- Reused agents: ${this.getAgentReuseStats().reusedCount}
- Total agents: ${this.getAgentReuseStats().totalCount}
- Reuse rate: ${(this.getAgentReuseStats().reuseRate * 100).toFixed(1)}%

*Generated by Enhanced Maestro Orchestrator with Agent Reuse*
`;
      
      await writeFile(join(specsDir, 'design.md'), designContent);
      console.log(`âœ… Design created at: docs/maestro/specs/${featureName}/design.md`);
    }
    
    // Simplified version of the enhanced agent selection
    async getOptimalAgentTypes(requiredCapabilities, taskType, maxAgents = 2) {
      // Check for reusable agents first
      const reusableAgents = await this.findReusableAgents(requiredCapabilities, maxAgents);
      
      if (reusableAgents.length >= maxAgents) {
        console.log(`ğŸ”„ Found ${reusableAgents.length} reusable agents`);
        return reusableAgents.map(agentId => {
          const pooledAgent = this.agentPool.get(agentId);
          return pooledAgent?.type || 'general';
        });
      }
      
      // Fallback to configured types
      return this.getConfiguredAgentTypes(requiredCapabilities, taskType, maxAgents);
    }
    
    async findReusableAgents(requiredCapabilities, maxAgents) {
      const reusableAgents = [];
      
      // Simple capability matching
      for (const [agentId, pooledAgent] of this.agentPool) {
        if (reusableAgents.length >= maxAgents) break;
        
        if (pooledAgent.status === 'available') {
          // Check if agent has matching capabilities
          const hasCapabilities = requiredCapabilities.some(cap => 
            pooledAgent.capabilities.includes(cap)
          );
          
          if (hasCapabilities) {
            reusableAgents.push(agentId);
          }
        }
      }
      
      return reusableAgents;
    }
    
    getConfiguredAgentTypes(requiredCapabilities, taskType, maxAgents) {
      const taskTypeAgents = {
        'design-generation': ['design-architect', 'system-architect'],
        'task-planning': ['task-planner', 'planner'],  
        'task-implementation': ['developer', 'coder']
      };
      
      return (taskTypeAgents[taskType] || ['developer', 'analyst']).slice(0, maxAgents);
    }
    
    async executeTaskWithManagedAgent(agentTypes, task, capabilities) {
      const acquiredAgents = [];
      const spawnedAgents = [];
      
      console.log(`ğŸ”§ Executing task with agent types: ${agentTypes.join(', ')}`);
      
      try {
        // Try to reuse existing agents first
        const reusedAgents = await this.findReusableAgents(capabilities, agentTypes.length);
        acquiredAgents.push(...reusedAgents);
        
        console.log(`â™»ï¸  Reused ${reusedAgents.length} agents`);
        
        // Spawn additional agents if needed
        const needed = agentTypes.length - reusedAgents.length;
        if (needed > 0) {
          for (let i = 0; i < needed; i++) {
            const agentType = agentTypes[i];
            const agentId = await this.agentManager.createAgent(agentType, {
              id: `${agentType}-test`,
              type: agentType,
              capabilities: capabilities
            });
            
            await this.agentManager.startAgent(agentId);
            
            // Add to pool for reuse
            await this.addAgentToPool(agentId, agentType, capabilities);
            
            spawnedAgents.push(agentId);
            acquiredAgents.push(agentId);
          }
          
          console.log(`ğŸ†• Spawned ${spawnedAgents.length} new agents`);
        }
        
        // Mark agents as busy
        await this.markAgentsAsBusy(reusedAgents, task.id);
        
        // Execute task
        task.assignedAgent = acquiredAgents[0] || 'default';
        await this.mainOrchestrator.assignTask(task);
        
        console.log(`âœ… Task completed with ${reusedAgents.length} reused + ${spawnedAgents.length} spawned agents`);
        
      } finally {
        // Release agents back to pool
        await this.releaseAgentsToPool(acquiredAgents, spawnedAgents);
      }
    }
    
    async addAgentToPool(agentId, agentType, capabilities) {
      const pooledAgent = {
        id: agentId,
        type: agentType,
        capabilities: capabilities,
        status: 'available',
        lastUsed: new Date(),
        usageCount: 0,
        createdAt: new Date()
      };
      
      this.agentPool.set(agentId, pooledAgent);
      
      // Update capability index
      for (const capability of capabilities) {
        if (!this.capabilityIndex.has(capability)) {
          this.capabilityIndex.set(capability, new Set());
        }
        this.capabilityIndex.get(capability).add(agentId);
      }
    }
    
    async markAgentsAsBusy(agentIds, taskId) {
      for (const agentId of agentIds) {
        const pooledAgent = this.agentPool.get(agentId);
        if (pooledAgent) {
          pooledAgent.status = 'busy';
          pooledAgent.lastUsed = new Date();
          pooledAgent.usageCount++;
        }
      }
    }
    
    async releaseAgentsToPool(allAgents, spawnedAgents) {
      for (const agentId of allAgents) {
        const pooledAgent = this.agentPool.get(agentId);
        if (pooledAgent) {
          pooledAgent.status = 'available';
        }
      }
    }
    
    getAgentReuseStats() {
      const agents = Array.from(this.agentPool.values());
      const totalCount = agents.length;
      const reusedCount = agents.filter(a => a.usageCount > 1).length;
      const reuseRate = totalCount > 0 ? reusedCount / totalCount : 0;
      
      return { totalCount, reusedCount, reuseRate };
    }
    
    getAgentPoolStats() {
      const agents = Array.from(this.agentPool.values());
      return {
        totalAgents: agents.length,
        availableAgents: agents.filter(a => a.status === 'available').length,
        busyAgents: agents.filter(a => a.status === 'busy').length,
        averageUsage: agents.reduce((sum, a) => sum + a.usageCount, 0) / agents.length || 0,
        capabilitiesCovered: this.capabilityIndex.size
      };
    }
  }

  // Run the test workflow
  const maestro = new TestMaestroOrchestrator();
  
  console.log('\nğŸ”¬ Test 1: Create Spec');
  await maestro.createSpec('agent-reuse-validation', 'Test agent reuse functionality with multiple design tasks');
  
  console.log('\nğŸ”¬ Test 2: Generate First Design (should spawn new agents)');
  await maestro.generateDesign('agent-reuse-validation');
  
  console.log('\nğŸ”¬ Test 3: Generate Second Design (should reuse agents)');  
  await maestro.generateDesign('agent-reuse-validation-2');
  
  console.log('\nğŸ”¬ Test 4: Generate Third Design (should reuse agents)');
  await maestro.generateDesign('agent-reuse-validation-3');
  
  // Display final statistics
  console.log('\nğŸ“Š Final Agent Pool Statistics:');
  console.log('=' .repeat(40));
  const stats = maestro.getAgentPoolStats();
  const reuseStats = maestro.getAgentReuseStats();
  
  console.log(`Total Agents: ${stats.totalAgents}`);
  console.log(`Available Agents: ${stats.availableAgents}`);
  console.log(`Busy Agents: ${stats.busyAgents}`);
  console.log(`Average Usage: ${stats.averageUsage.toFixed(2)}`);
  console.log(`Capabilities Covered: ${stats.capabilitiesCovered}`);
  console.log(`Reuse Rate: ${(reuseStats.reuseRate * 100).toFixed(1)}%`);
  
  console.log('\nâœ… Agent Reuse Test Complete!');
  
  // Verify expected behaviors
  console.log('\nğŸ§ª Verification Results:');
  console.log(`âœ… Agent pool contains ${stats.totalAgents} agents (expected: >0)`);
  console.log(`âœ… Agent reuse rate: ${(reuseStats.reuseRate * 100).toFixed(1)}% (expected: >50%)`);
  console.log(`âœ… Multiple capabilities indexed: ${stats.capabilitiesCovered} (expected: â‰¥3)`);
  
  if (stats.totalAgents > 0 && reuseStats.reuseRate > 0.5 && stats.capabilitiesCovered >= 3) {
    console.log('\nğŸ‰ All tests passed! Agent reuse is working correctly.');
  } else {
    console.log('\nâš ï¸  Some tests failed. Review the implementation.');
  }
}

// Run the test
testMaestroWithAgentReuse().catch(console.error);