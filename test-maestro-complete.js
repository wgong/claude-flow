#!/usr/bin/env node

/**
 * Complete Test for Maestro Specs-Driven Flow
 * Tests the full workflow: spec -> design -> tasks -> implement
 */

import { readFile, writeFile, mkdir } from 'fs/promises';
import { join } from 'path';

// Enhanced mock implementations
class MockLogger {
  info(msg) { console.log(`â„¹ï¸  ${msg}`); }
  warn(msg) { console.log(`âš ï¸  ${msg}`); }
  error(msg) { console.log(`âŒ ${msg}`); }
  debug(msg) { console.log(`ğŸ› ${msg}`); }
}

class MockAgentManager {
  constructor() {
    this.agents = new Map();
  }
  
  async createAgent(type, profile) {
    const agentId = `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
    this.agents.set(agentId, { type, profile, status: 'created' });
    console.log(`ğŸ¤– Agent created: ${agentId} (${type})`);
    return agentId;
  }
  
  async startAgent(agentId) {
    const agent = this.agents.get(agentId);
    if (agent) {
      agent.status = 'running';
      console.log(`â–¶ï¸  Agent started: ${agentId}`);
    }
  }
  
  async stopAgent(agentId) {
    const agent = this.agents.get(agentId);
    if (agent) {
      agent.status = 'stopped';
      console.log(`â¹ï¸  Agent stopped: ${agentId}`);
      this.agents.delete(agentId);
    }
  }
}

class MockOrchestrator {
  async assignTask(task) {
    console.log(`ğŸ“‹ Task "${task.description}" assigned to ${task.assignedAgent}`);
    // Simulate realistic task execution
    await new Promise(resolve => setTimeout(resolve, 50));
    return { success: true, duration: 50 };
  }
}

// Complete Maestro test implementation
class CompleteMaestroTest {
  constructor() {
    this.maestroState = new Map();
    this.agentPool = new Map();
    this.capabilityIndex = new Map();
    this.logger = new MockLogger();
    this.agentManager = new MockAgentManager();
    this.mainOrchestrator = new MockOrchestrator();
    this.taskCounter = 0;
  }

  // Test 1: Create Spec
  async createSpec(featureName, initialRequest) {
    console.log(`\nğŸ“‹ TEST 1: Creating spec for '${featureName}'`);
    
    const workflowState = {
      featureName,
      currentPhase: 'Requirements Clarification',
      currentTaskIndex: 0,
      status: 'active',
      lastActivity: new Date(),
      history: [{
        phase: 'Requirements Clarification',
        status: 'in-progress',
        timestamp: new Date()
      }]
    };
    
    this.maestroState.set(featureName, workflowState);
    
    const specsDir = join(process.cwd(), 'docs', 'maestro', 'specs', featureName);
    await mkdir(specsDir, { recursive: true });
    
    const requirementsContent = `# Requirements for ${featureName}

## High-Level Request
${initialRequest}

## User Stories
- As a developer, I want ${initialRequest.toLowerCase()}, so that the system works efficiently
- As a user, I want reliable performance, so that I can depend on the system

## Acceptance Criteria
- [ ] Feature functions as described in requirements
- [ ] Agent reuse rate is >70% after initial setup
- [ ] Task execution time is optimized
- [ ] All edge cases are handled properly

## Technical Requirements
- [ ] Integration with existing agent management system
- [ ] Error handling and validation throughout
- [ ] Performance monitoring and metrics collection
- [ ] Comprehensive test coverage

*Generated by Complete Maestro Test Framework*
`;
    
    await writeFile(join(specsDir, 'requirements.md'), requirementsContent);
    console.log(`âœ… Requirements created successfully`);
    
    return workflowState;
  }

  // Test 2: Generate Design with Agent Reuse
  async generateDesign(featureName) {
    console.log(`\nğŸ¨ TEST 2: Generating design for '${featureName}'`);
    
    const state = this.maestroState.get(featureName);
    if (!state) throw new Error(`No workflow state found for '${featureName}'`);
    
    // Test configurable agent selection
    const designTask = {
      id: `design-task-${featureName}-${++this.taskCounter}`,
      type: 'design-generation',
      description: `Generate comprehensive design for ${featureName}`,
      metadata: { featureName, phase: 'Research & Design' }
    };

    // Use the enhanced agent selection
    const optimalAgentTypes = await this.getOptimalAgentTypes(
      ['design', 'architecture', 'analysis'],
      'design-generation',
      2
    );

    console.log(`ğŸ¯ Optimal agents selected: ${optimalAgentTypes.join(', ')}`);
    
    await this.executeTaskWithManagedAgent(
      optimalAgentTypes,
      designTask,
      ['design', 'architecture', 'analysis']
    );

    // Update workflow state
    state.currentPhase = 'Research & Design';
    state.history.push({
      phase: 'Research & Design',
      status: 'completed',
      timestamp: new Date()
    });

    // Create design document
    const specsDir = join(process.cwd(), 'docs', 'maestro', 'specs', featureName);
    const agentStats = this.getAgentPoolStats();
    
    const designContent = `# Design for ${featureName}

## Architecture Overview
Advanced system architecture leveraging enhanced agent reuse patterns for optimal performance.

## Component Design
### Agent Pool Management
- **Pool Size**: ${agentStats.totalAgents} agents
- **Reuse Rate**: ${((agentStats.totalAgents > 0 ? agentStats.totalAgents - 2 : 0) / Math.max(agentStats.totalAgents, 1) * 100).toFixed(1)}%
- **Capabilities Covered**: ${agentStats.capabilitiesCovered}

### Core Components
1. **Enhanced Agent Selector**: Intelligent capability-based selection
2. **Agent Pool Manager**: Efficient resource reuse and lifecycle management  
3. **Task Orchestrator**: Optimal task distribution and execution

## Performance Requirements
- Agent reuse rate: >70% after initial pool establishment
- Task selection time: <50ms average
- Pool management overhead: <5% of total resources

*Generated by Enhanced Maestro with Agent Reuse Statistics*
`;
    
    await writeFile(join(specsDir, 'design.md'), designContent);
    console.log(`âœ… Design generated with agent reuse metrics`);
    
    return designContent;
  }

  // Test 3: Generate Tasks with Enhanced Planning
  async generateTasks(featureName) {
    console.log(`\nğŸ“‹ TEST 3: Generating tasks for '${featureName}'`);
    
    const state = this.maestroState.get(featureName);
    if (!state) throw new Error(`No workflow state found for '${featureName}'`);
    
    // Test task planning with agent reuse
    const taskPlanningTask = {
      id: `task-planning-${featureName}-${++this.taskCounter}`,
      type: 'task-planning',
      description: `Generate implementation tasks for ${featureName}`,
      metadata: { 
        featureName,
        phase: 'Implementation Planning',
        outputPath: join(process.cwd(), 'docs', 'maestro', 'specs', featureName, 'tasks.md')
      }
    };

    // Use enhanced planning agent selection
    const optimalPlannerTypes = await this.getOptimalAgentTypes(
      ['project-management', 'task-breakdown', 'planning'],
      'task-planning',
      1
    );

    console.log(`ğŸ“ Task planning agents: ${optimalPlannerTypes.join(', ')}`);
    
    await this.executeTaskWithManagedAgent(
      optimalPlannerTypes,
      taskPlanningTask,
      ['project-management', 'task-breakdown', 'planning']
    );

    // Update workflow state
    state.currentPhase = 'Implementation Planning';
    state.history.push({
      phase: 'Implementation Planning',
      status: 'completed',
      timestamp: new Date()
    });

    // Generate tasks content
    const tasksContent = `# Implementation Tasks for ${featureName}

## Task Breakdown

### Phase 1: Foundation Setup
- [ ] 1. Set up enhanced agent pool management infrastructure
- [ ] 2. Implement capability-based agent indexing system
- [ ] 3. Create agent lifecycle management with reuse patterns

### Phase 2: Core Implementation  
- [ ] 4. Develop intelligent agent selection algorithms
- [ ] 5. Implement task orchestration with agent reuse
- [ ] 6. Add performance monitoring and metrics collection

### Phase 3: Integration & Testing
- [ ] 7. Integrate with existing orchestrator systems
- [ ] 8. Create comprehensive test suite for agent reuse
- [ ] 9. Implement error handling and fallback mechanisms

### Phase 4: Optimization & Validation
- [ ] 10. Optimize agent pool sizing and cleanup strategies
- [ ] 11. Validate performance improvements and resource usage
- [ ] 12. Conduct end-to-end integration testing

## Dependencies
- Task 2 depends on Task 1 (infrastructure before indexing)
- Task 5 depends on Task 4 (orchestration after selection)
- Tasks 7-9 depend on Tasks 4-6 (integration after core implementation)
- Tasks 10-12 depend on all previous tasks (optimization after implementation)

## Implementation Notes
- Use existing agent management patterns where possible
- Maintain backward compatibility with current orchestrator
- Focus on minimal-change approach for maximum stability
- Implement comprehensive monitoring from the start

*Generated by Enhanced Task Planning with Agent Reuse - Agent Pool Stats: ${this.getAgentPoolStats().totalAgents} agents*
`;

    const specsDir = join(process.cwd(), 'docs', 'maestro', 'specs', featureName);
    await writeFile(join(specsDir, 'tasks.md'), tasksContent);
    console.log(`âœ… Tasks generated with ${12} implementation items`);
    
    return tasksContent;
  }

  // Test 4: Implement Task with Agent Pool
  async implementTask(featureName, taskId) {
    console.log(`\nğŸ”¨ TEST 4: Implementing task ${taskId} for '${featureName}'`);
    
    const state = this.maestroState.get(featureName);
    if (!state) throw new Error(`No workflow state found for '${featureName}'`);
    
    // Simulate reading tasks
    const taskDescription = `Task ${taskId}: Enhanced agent reuse implementation`;
    
    const implementationTask = {
      id: `impl-task-${featureName}-${taskId}-${++this.taskCounter}`,
      type: 'task-implementation',
      description: `Implement: ${taskDescription}`,
      metadata: { 
        featureName,
        taskId,
        phase: 'Task Execution'
      }
    };

    // Use enhanced developer agent selection
    const optimalDeveloperTypes = await this.getOptimalAgentTypes(
      ['implementation', 'coding', 'testing'],
      'task-implementation',
      2
    );

    console.log(`ğŸ‘¨â€ğŸ’» Implementation agents: ${optimalDeveloperTypes.join(', ')}`);
    
    await this.executeTaskWithManagedAgent(
      optimalDeveloperTypes,
      implementationTask,
      ['implementation', 'coding', 'testing']
    );

    // Update workflow state
    state.currentPhase = 'Task Execution';
    state.currentTaskIndex = taskId;
    state.lastActivity = new Date();
    
    console.log(`âœ… Task ${taskId} implemented successfully`);
    
    return implementationTask;
  }

  // Enhanced agent selection logic (from actual implementation)
  async getOptimalAgentTypes(requiredCapabilities, taskType, maxAgents = 2) {
    // Check for reusable agents first
    const reusableAgents = await this.findReusableAgents(requiredCapabilities, maxAgents);
    
    if (reusableAgents.length >= maxAgents) {
      console.log(`â™»ï¸  Found ${reusableAgents.length} reusable agents for task`);
      return reusableAgents.map(agentId => {
        const pooledAgent = this.agentPool.get(agentId);
        return pooledAgent?.type || 'general';
      });
    }
    
    // Fallback to configured agent types based on capabilities and task type
    return this.getConfiguredAgentTypes(requiredCapabilities, taskType, maxAgents);
  }

  async findReusableAgents(requiredCapabilities, maxAgents) {
    const reusableAgents = [];
    
    // Use capability index for efficient lookup
    let candidateIds = null;
    
    for (const capability of requiredCapabilities) {
      const agentsWithCapability = this.capabilityIndex.get(capability);
      
      if (!agentsWithCapability || agentsWithCapability.size === 0) {
        continue;
      }
      
      if (candidateIds === null) {
        candidateIds = new Set(agentsWithCapability);
      } else {
        // Find intersection - agents with ALL required capabilities
        const intersection = new Set();
        candidateIds.forEach(id => {
          if (agentsWithCapability.has(id)) {
            intersection.add(id);
          }
        });
        candidateIds = intersection;
      }
    }
    
    // Get available agents from candidates
    if (candidateIds && candidateIds.size > 0) {
      for (const agentId of candidateIds) {
        if (reusableAgents.length >= maxAgents) break;
        
        const pooledAgent = this.agentPool.get(agentId);
        if (pooledAgent && pooledAgent.status === 'available') {
          reusableAgents.push(agentId);
        }
      }
    }
    
    return reusableAgents;
  }

  getConfiguredAgentTypes(requiredCapabilities, taskType, maxAgents) {
    // Smart mapping based on task type and capabilities
    const taskTypeAgents = {
      'design-generation': ['design-architect', 'system-architect'],
      'task-planning': ['task-planner', 'planner'],
      'task-implementation': ['developer', 'coder'],
      'code-review': ['reviewer', 'analyst'],
      'research': ['researcher', 'analyst'],
      'documentation': ['requirements-engineer', 'steering-author']
    };

    // Capability-based fallback mapping
    const capabilityAgents = {
      'design': ['design-architect', 'system-architect'],
      'architecture': ['system-architect', 'design-architect'],
      'implementation': ['developer', 'coder'],
      'coding': ['developer', 'coder'],
      'testing': ['tester', 'developer'],
      'project-management': ['task-planner'],
      'task-breakdown': ['task-planner'],
      'planning': ['task-planner', 'planner'],
      'analysis': ['analyst', 'researcher']
    };

    // Try task type first
    let agentTypes = taskTypeAgents[taskType] || [];

    // If no direct task type match, build from capabilities
    if (agentTypes.length === 0) {
      const typeSet = new Set();
      
      for (const capability of requiredCapabilities) {
        const possibleTypes = capabilityAgents[capability] || [];
        possibleTypes.forEach(type => typeSet.add(type));
      }
      
      agentTypes = Array.from(typeSet);
    }

    // Fallback to general agent types
    if (agentTypes.length === 0) {
      agentTypes = ['developer', 'analyst'];
    }

    return agentTypes.slice(0, maxAgents);
  }

  // Enhanced task execution with agent reuse
  async executeTaskWithManagedAgent(agentTypes, task, capabilities) {
    const acquiredAgents = [];
    const spawnedAgents = [];
    
    try {
      // Step 1: Try to reuse existing agents first
      const reusedAgents = await this.findReusableAgents(capabilities, agentTypes.length);
      acquiredAgents.push(...reusedAgents);
      
      // Step 2: Spawn additional agents only if needed
      const needed = agentTypes.length - reusedAgents.length;
      if (needed > 0) {
        const typesToSpawn = agentTypes.slice(0, needed);
        
        for (const agentType of typesToSpawn) {
          const agentId = await this.agentManager.createAgent(agentType, {
            id: `${agentType}-${task.metadata?.featureName || 'test'}`,
            type: agentType,
            capabilities: capabilities
          });
          
          await this.agentManager.startAgent(agentId);
          
          // Add to pool for future reuse
          await this.addAgentToPool(agentId, agentType, capabilities);
          
          spawnedAgents.push(agentId);
          acquiredAgents.push(agentId);
        }
      }
      
      // Step 3: Mark reused agents as busy
      await this.markAgentsAsBusy(reusedAgents, task.id);
      
      // Assign task to first available agent
      const assignedAgent = acquiredAgents[0] || 'default';
      task.assignedAgent = assignedAgent;
      
      // Execute task through main orchestrator
      await this.mainOrchestrator.assignTask(task);
      
      console.log(`ğŸ“Š Execution: ${reusedAgents.length} reused + ${spawnedAgents.length} spawned agents`);
      
    } finally {
      // Step 4: Release agents back to pool
      await this.releaseAgentsToPool(acquiredAgents, spawnedAgents);
    }
  }

  async addAgentToPool(agentId, agentType, capabilities) {
    const pooledAgent = {
      id: agentId,
      type: agentType,
      capabilities: capabilities,
      status: 'available',
      lastUsed: new Date(),
      usageCount: 0,
      createdAt: new Date()
    };
    
    this.agentPool.set(agentId, pooledAgent);
    
    // Update capability index for efficient lookup
    for (const capability of capabilities) {
      if (!this.capabilityIndex.has(capability)) {
        this.capabilityIndex.set(capability, new Set());
      }
      this.capabilityIndex.get(capability).add(agentId);
    }
  }

  async markAgentsAsBusy(agentIds, taskId) {
    for (const agentId of agentIds) {
      const pooledAgent = this.agentPool.get(agentId);
      if (pooledAgent) {
        pooledAgent.status = 'busy';
        pooledAgent.lastUsed = new Date();
        pooledAgent.usageCount++;
      }
    }
  }

  async releaseAgentsToPool(allAgents, spawnedAgents) {
    for (const agentId of allAgents) {
      const pooledAgent = this.agentPool.get(agentId);
      if (pooledAgent) {
        // Simple policy: keep agents available for reuse
        pooledAgent.status = 'available';
      }
    }
  }

  getAgentPoolStats() {
    const agents = Array.from(this.agentPool.values());
    const totalAgents = agents.length;
    const availableAgents = agents.filter(a => a.status === 'available').length;
    const busyAgents = agents.filter(a => a.status === 'busy').length;
    const averageUsage = totalAgents > 0 ? agents.reduce((sum, a) => sum + a.usageCount, 0) / totalAgents : 0;
    const capabilitiesCovered = this.capabilityIndex.size;
    
    // Calculate reuse rate (agents with usage > 1)
    const reusedAgents = agents.filter(a => a.usageCount > 1).length;
    const reuseRate = totalAgents > 0 ? reusedAgents / totalAgents : 0;
    
    return {
      totalAgents,
      availableAgents,
      busyAgents,
      averageUsage,
      capabilitiesCovered,
      reuseRate
    };
  }

  getWorkflowState(featureName) {
    return this.maestroState.get(featureName);
  }
}

// Run complete test workflow
async function runCompleteTest() {
  console.log('ğŸ§ª COMPLETE MAESTRO SPECS-DRIVEN FLOW TEST');
  console.log('=' .repeat(60));

  const maestro = new CompleteMaestroTest();
  const featureName = 'complete-agent-reuse-system';
  
  try {
    // Test 1: Create Spec
    await maestro.createSpec(featureName, 'Complete agent reuse system with intelligent selection and pool management');
    
    // Test 2: Generate Design (should spawn initial agents)
    await maestro.generateDesign(featureName);
    
    // Test 3: Generate Tasks (should reuse design agents for planning)
    await maestro.generateTasks(featureName);
    
    // Test 4: Implement first task (should reuse or spawn development agents)
    await maestro.implementTask(featureName, 1);
    
    // Test 5: Implement second task (should reuse development agents)
    await maestro.implementTask(featureName, 2);
    
    // Display comprehensive statistics
    console.log('\nğŸ“Š COMPLETE TEST RESULTS');
    console.log('=' .repeat(40));
    
    const finalStats = maestro.getAgentPoolStats();
    const workflowState = maestro.getWorkflowState(featureName);
    
    console.log(`\nğŸ—ï¸  Workflow Status:`);
    console.log(`   Feature: ${featureName}`);
    console.log(`   Current Phase: ${workflowState.currentPhase}`);
    console.log(`   Current Task: ${workflowState.currentTaskIndex}`);
    console.log(`   Total Phases: ${workflowState.history.length}`);
    
    console.log(`\nğŸ¤– Agent Pool Statistics:`);
    console.log(`   Total Agents: ${finalStats.totalAgents}`);
    console.log(`   Available: ${finalStats.availableAgents}`);
    console.log(`   Busy: ${finalStats.busyAgents}`);
    console.log(`   Average Usage: ${finalStats.averageUsage.toFixed(2)}`);
    console.log(`   Capabilities Covered: ${finalStats.capabilitiesCovered}`);
    console.log(`   Reuse Rate: ${(finalStats.reuseRate * 100).toFixed(1)}%`);
    
    // Validation checks
    console.log(`\nâœ… VALIDATION RESULTS:`);
    const validations = [
      { test: 'Workflow State Created', pass: !!workflowState, expected: true },
      { test: 'Multiple Phases Completed', pass: workflowState.history.length >= 3, expected: 'â‰¥3 phases' },
      { test: 'Agent Pool Active', pass: finalStats.totalAgents > 0, expected: '>0 agents' },
      { test: 'Agent Reuse Working', pass: finalStats.reuseRate > 0.5, expected: '>50% reuse' },
      { test: 'Multiple Capabilities', pass: finalStats.capabilitiesCovered >= 6, expected: 'â‰¥6 capabilities' },
      { test: 'Average Usage Optimal', pass: finalStats.averageUsage >= 1.5, expected: 'â‰¥1.5 usage/agent' }
    ];
    
    let passedCount = 0;
    validations.forEach(({ test, pass, expected }) => {
      const status = pass ? 'âœ…' : 'âŒ';
      console.log(`   ${status} ${test}: ${pass} (expected: ${expected})`);
      if (pass) passedCount++;
    });
    
    console.log(`\nğŸ¯ Overall Success: ${passedCount}/${validations.length} tests passed`);
    
    if (passedCount === validations.length) {
      console.log('\nğŸ‰ ALL TESTS PASSED! Maestro specs-driven flow with agent reuse is working perfectly.');
    } else {
      console.log('\nâš ï¸  Some tests failed. Review the implementation for issues.');
    }
    
    // Show generated files
    console.log(`\nğŸ“ Generated Files:`);
    console.log(`   ğŸ“‹ docs/maestro/specs/${featureName}/requirements.md`);
    console.log(`   ğŸ¨ docs/maestro/specs/${featureName}/design.md`);
    console.log(`   ğŸ“ docs/maestro/specs/${featureName}/tasks.md`);
    
  } catch (error) {
    console.error('\nâŒ Test failed with error:', error.message);
    console.error(error.stack);
  }
}

// Run the complete test
runCompleteTest().catch(console.error);